<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · GaussianBosonSamplingMPS</title><meta name="title" content="Reference · GaussianBosonSamplingMPS"/><meta property="og:title" content="Reference · GaussianBosonSamplingMPS"/><meta property="twitter:title" content="Reference · GaussianBosonSamplingMPS"/><meta name="description" content="Documentation for GaussianBosonSamplingMPS."/><meta property="og:description" content="Documentation for GaussianBosonSamplingMPS."/><meta property="twitter:description" content="Documentation for GaussianBosonSamplingMPS."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GaussianBosonSamplingMPS</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Superboson-matrix-product-states"><span>Superboson matrix-product states</span></a></li><li><a class="tocitem" href="#Gaussian-states-and-operations"><span>Gaussian states and operations</span></a></li><li><a class="tocitem" href="#Boson-sampling-output-simulation"><span>Boson sampling output simulation</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/borealis/">Borealis experiment</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Superboson-matrix-product-states"><a class="docs-heading-anchor" href="#Superboson-matrix-product-states">Superboson matrix-product states</a><a id="Superboson-matrix-product-states-1"></a><a class="docs-heading-anchor-permalink" href="#Superboson-matrix-product-states" title="Permalink"></a></h2><p>The package introduces a new type, called <code>SuperBosonMPS</code>, which is basically an ordinary <code>MPS</code> from ITensors with some additional decoration. This MPS represents a generic mixed state in a many-body bosonic Fock space using the <em>superboson</em> formalism [<a href="../#Schmutz1978">4</a>], which translates mixed states to pure states in an enlarged Hilbert space.</p><p>It is a subtype of <code>AbstractMPS</code>, therefore you can use most of the methods already defined by ITensors on the <code>SuperBosonMPS</code> type too.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.SuperBosonMPS" href="#GaussianBosonSamplingMPS.SuperBosonMPS"><code>GaussianBosonSamplingMPS.SuperBosonMPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SuperBosonMPS</code></pre><p>A finite-size matrix-product state type that represents mixed states in the superboson formalism [<a href="../#Schmutz1978">4</a>].</p><p><strong>References</strong></p><ul><li>[<a href="../#Schmutz1978">4</a>] Schmutz, M. <em>Z Physik B</em> 30, 97–106 (1978)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L12-L21">source</a></section></article><h3 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h3><p>To make working with a superboson space easier, this library provides the following utilities.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianStates.nmodes" href="#GaussianStates.nmodes"><code>GaussianStates.nmodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nmodes(v::SuperBosonMPS)</code></pre><p>Return the number of &quot;true&quot; bosonic modes contained in the SuperBosonMPS <code>v</code>, i.e. half its actual length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.enlargelocaldim" href="#GaussianBosonSamplingMPS.enlargelocaldim"><code>GaussianBosonSamplingMPS.enlargelocaldim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enlargelocaldim(v::AbstractMPS, newdim)</code></pre><p>Return a new MPS with the local dimension increased to <code>newdim</code>.</p><p>Note that the new MPS will be defined on a new set of site indices, so it will be incompatible with the original one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_construction.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.sb_siteinds" href="#GaussianBosonSamplingMPS.sb_siteinds"><code>GaussianBosonSamplingMPS.sb_siteinds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sb_siteinds(; nmodes, maxnumber)</code></pre><p>Return a list of ITensor site indices suited to define a superbosonic state, with alternating &quot;physical&quot; and &quot;ancillary&quot; sites.</p><p><strong>Keyword arguments (mandatory)</strong></p><ul><li><code>nmodes</code>: the number of &quot;real-world&quot; bosonic modes of the system (the actual MPS will have <code>2nmodes</code> sites).</li><li><code>maxnumber</code>: maximum number of bosons allowed on each site. The local Hilbert spaces will be truncated to a dimension of <code>maxnumber+1</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sb_siteinds(; nmodes=2, maxnumber=4)
4-element Vector{Index{Int64}}:
 (dim=5|id=962|&quot;Boson,Site,n=1,phy&quot;)
 (dim=5|id=41|&quot;Boson,Site,anc,n=1&quot;)
 (dim=5|id=794|&quot;Boson,Site,n=2,phy&quot;)
 (dim=5|id=198|&quot;Boson,Site,anc,n=2&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L433-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.sb_outer" href="#GaussianBosonSamplingMPS.sb_outer"><code>GaussianBosonSamplingMPS.sb_outer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sb_outer(ψ::MPS)</code></pre><p>Compute the projection operator <span>$|ψ⟩⟨ψ| / ‖ψ‖²$</span>, from the MPS <code>ψ</code> representing a pure state, returning a <code>SuperBosonMPS</code> object (of double the size).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L463-L468">source</a></section></article><h3 id="Expectation-values-and-sampling"><a class="docs-heading-anchor" href="#Expectation-values-and-sampling">Expectation values and sampling</a><a id="Expectation-values-and-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Expectation-values-and-sampling" title="Permalink"></a></h3><p>To extract physical information from a <code>SuperBosonMPS</code> object, you can use the <code>expect</code>, <code>correlation_matrix</code> and <code>sample</code> functions, which work exactly as in the ITensorMPS library.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ITensorMPS.expect" href="#ITensorMPS.expect"><code>ITensorMPS.expect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expect(v::SuperBosonMPS, op::AbstractString...; kwargs...)
expect(v::SuperBosonMPS, op::Matrix{&lt;:Number}...; kwargs...)
expect(v::SuperBosonMPS, ops; kwargs...)</code></pre><p>Given a superbosonic MPS <code>v</code> and a single operator name or matrix, returns a vector of the expected value of the operator on each site of the SuperBosonMPS.</p><p>If multiple operator names are provided, returns a tuple of expectation value vectors.</p><p>If a container of operator names is provided, returns the same type of container with names replaced by vectors of expectation values.</p><p><strong>Optional keyword arguments</strong></p><ul><li><code>sites = 1:nmodes(v)</code>: compute expected values only for modes in the given range</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">N = 10

s = sb_siteinds(&quot;Boson&quot;, N)
v = sb_outer(random_mps(s; linkdims=4))
expect(v, &quot;N&quot;)  # compute for all sites
expect(v, &quot;N&quot;; sites=2:4)  # compute for sites 2, 3 and 4
expect(v, &quot;N&quot;; sites=3)  # compute for site 3 only (output will be a scalar)
expect(v, [&quot;A*Adag&quot;, &quot;N&quot;])  # compute A*Adag and N for all sites
expect(v, [0 0; 0 1])  # same as expect(v, &quot;N&quot;) if maxnumber == 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L296-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ITensorMPS.correlation_matrix" href="#ITensorMPS.correlation_matrix"><code>ITensorMPS.correlation_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correlation_matrix(
    v::SuperBosonMPS, A::AbstractString, B::AbstractString; kwargs...
)

correlation_matrix(
    v::SuperBosonMPS, A::Matrix{&lt;:Number}, B::Matrix{&lt;:Number}; kwargs...
)</code></pre><p>Given a SuperBosonMPS <code>v</code> representing a state <span>$ρ$</span> and two strings or matrices <code>A</code> and <code>B</code> denoting operators (as recognized by the <code>op</code> function), computes the two-point correlation function matrix <span>$C_{ij} = \textrm{tr}(A_i B_j ρ)$</span> using efficient MPS techniques. Returns the matrix <code>C</code>.</p><p><strong>Optional keyword arguments</strong></p><ul><li><code>sites = 1:nmodes(v)</code>: compute correlations only for sites in the given range</li><li><code>ishermitian = false</code> : if <code>false</code>, force independent calculations of the matrix elements above and below the diagonal, while if <code>true</code> assume they are complex conjugates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = siteinds(&quot;Boson&quot;, 3; dim=4);

julia&gt; vac = sb_outer(MPS(ComplexF64, s, &quot;0&quot;));

julia&gt; correlation_matrix(vac, &quot;x&quot;, &quot;x&quot;)
3×3 Matrix{ComplexF64}:
 0.5+0.0im  0.0+0.0im  0.0+0.0im
 0.0-0.0im  0.5+0.0im  0.0+0.0im
 0.0-0.0im  0.0-0.0im  0.5+0.0im

julia&gt; correlation_matrix(vac, &quot;p&quot;, &quot;x&quot;)
3×3 Matrix{ComplexF64}:
 0.0-0.5im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0-0.5im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0-0.5im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L662-L701">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ITensorMPS.sample" href="#ITensorMPS.sample"><code>ITensorMPS.sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(m::SuperBosonMPS)</code></pre><p>Given a &quot;superbosonic&quot; MPS <code>m</code> with unit trace, compute a <code>Vector{Int}</code> of <code>nmodes(m)</code> elements corresponding to one sample of the probability distribution defined by the components of the density matrix that the MPS represents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/superbosons.jl#L588-L594">source</a></section></article><h2 id="Gaussian-states-and-operations"><a class="docs-heading-anchor" href="#Gaussian-states-and-operations">Gaussian states and operations</a><a id="Gaussian-states-and-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-states-and-operations" title="Permalink"></a></h2><p>This package works in tandem with the <a href="https://github.com/phaerrax/GaussianStates.jl/">GaussianStates</a> package, extending some of its methods to define them on matrix-product states (both ordinary and superbosonic ones).</p><h3 id="First-and-second-moments"><a class="docs-heading-anchor" href="#First-and-second-moments">First and second moments</a><a id="First-and-second-moments-1"></a><a class="docs-heading-anchor-permalink" href="#First-and-second-moments" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.firstmoments" href="#GaussianBosonSamplingMPS.firstmoments"><code>GaussianBosonSamplingMPS.firstmoments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">firstmoments(v; warn_atol=1e-14)</code></pre><p>Compute the first moments of the state <code>v</code>; return a vector in the <code>xpxp</code> order, i.e. the vector <span>$(⟨x_1⟩, ⟨p_1⟩, ⟨x_2⟩, ⟨p_2⟩, ..., ⟨x_N⟩, ⟨p_N⟩)$</span>.</p><p>The <code>warn_atol</code> keyword argument can be used to adjust the threshold used by the function to warn when the moments are not real.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/moments.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.covariancematrix" href="#GaussianBosonSamplingMPS.covariancematrix"><code>GaussianBosonSamplingMPS.covariancematrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">covariancematrix(v; warn_atol=1e-14)</code></pre><p>Compute the covariance matrix of the state <code>v</code>, in the <code>xpxp</code> order.</p><p>The <code>warn_atol</code> keyword argument can be used to adjust the threshold used by the function to warn when the moments are not real.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/moments.jl#L34-L41">source</a></section></article><h3 id="Gaussian-operations"><a class="docs-heading-anchor" href="#Gaussian-operations">Gaussian operations</a><a id="Gaussian-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-operations" title="Permalink"></a></h3><p>The following methods can be applied to an MPS in order to simulate quantum optical operations. The matrix elements of the squeezing operator are taken from [<a href="../#Marian1992_squeezing_fock_coefficients">5</a>].</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.attenuate" href="#GaussianBosonSamplingMPS.attenuate"><code>GaussianBosonSamplingMPS.attenuate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">attenuate(v::SuperBosonMPS, attenuation, n)</code></pre><p>Apply the attenuator channel <span>$ρ ↦ \sum_{k=0}^{+∞} B_k ρ \adj{B_k}$</span> to the <code>n</code>-th mode of the state <span>$ρ$</span> represented by the <code>SuperBosonMPS</code> <code>v</code>, where</p><p class="math-container">\[B_k = \sum_{m=0}^{+∞} \binom{m+k}{k}^{\frac12} (1-η^2)^{\frac{k}{2}} η^m |m⟩⟨m+k|\]</p><p>and <span>$η$</span> is the attenuation coefficient, such that <span>$\sum_{k=0}^{+\infty} B_k ρ \adj{B_k}$</span> is equal to <span>$|0⟩⟨0|$</span> when <span>$η = 0$</span> and to <span>$ρ$</span> when <span>$η = 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/attenuate.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianStates.displace" href="#GaussianStates.displace"><code>GaussianStates.displace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displace(v::Union{MPS,SuperBosonMPS}, α, n; kwargs...)</code></pre><p>Apply the displacement operator</p><p class="math-container">\[D(α) = \exp(α \adj{a} - \conj{α} a)\]</p><p>with <span>$α ∈ ℂ$</span>, to the <code>n</code>-th mode of the state represented by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/displace.jl#L26-L36">source</a></section><section><div><pre><code class="language-julia hljs">displace(v::Union{MPS,SuperBosonMPS}, α; kwargs...)</code></pre><p>Apply the displacement operator</p><p class="math-container">\[⨂_{i=1}^{n} D(α_i),
\quad
D(α) = \exp(α \adj{a} - \conj{α} a)\]</p><p>with <span>$α_i ∈ ℂ$</span>, to all modes of the state represented by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/displace.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianStates.squeeze" href="#GaussianStates.squeeze"><code>GaussianStates.squeeze</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">squeeze(v::Union{MPS,SuperBosonMPS}, z, n; kwargs...)</code></pre><p>Apply the squeezing operator</p><p class="math-container">\[S(z) = \exp\bigl(\tfrac12 z (\adj{a})^2 - \tfrac12 \conj{z} a^2\bigr)\]</p><p>with <span>$z ∈ ℂ$</span>, to the <code>n</code>-th mode of the state represented by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/squeeze.jl#L33-L43">source</a></section><section><div><pre><code class="language-julia hljs">squeeze(v::Union{MPS,SuperBosonMPS}, z; kwargs...)</code></pre><p>Apply the squeezing operator</p><p class="math-container">\[⨂_{i=1}^{n} S(z_i),
\quad
S(z) = \exp\bigl(\tfrac12 z (\adj{a})^2 - \tfrac12 \conj{z} a^2\bigr),\]</p><p>with <span>$z_i ∈ ℂ$</span>, to all modes of the state represented by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/squeeze.jl#L56-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianStates.squeeze2" href="#GaussianStates.squeeze2"><code>GaussianStates.squeeze2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">squeeze2(v::Union{MPS,SuperBosonMPS}, z, n1, n2; kwargs...)</code></pre><p>Apply the two-mode squeezing operator</p><p class="math-container">\[S₂(z) = \exp(z \adj{a} ⊗ \adj{a} - \conj{z} a ⊗ a)\]</p><p>with <span>$z ∈ ℂ$</span>, on modes <code>n1</code> and <code>n2</code> of the state represented by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/squeeze2.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianStates.beamsplitter" href="#GaussianStates.beamsplitter"><code>GaussianStates.beamsplitter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">beamsplitter(v::Union{MPS,SuperBosonMPS}, z, n1, n2; kwargs...)</code></pre><p>Apply the beam-splitter operator</p><p class="math-container">\[B(z) = \exp(z \adj{a} ⊗ a - \conj{z} a ⊗ \adj{a})\]</p><p>with <span>$z ∈ ℂ$</span>, to modes <code>n1</code> and <code>n2</code> of the state represented by <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_operations/beamsplitter.jl#L32-L42">source</a></section></article><h2 id="Boson-sampling-output-simulation"><a class="docs-heading-anchor" href="#Boson-sampling-output-simulation">Boson sampling output simulation</a><a id="Boson-sampling-output-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Boson-sampling-output-simulation" title="Permalink"></a></h2><p>Here lies the heart of this package: the following methods implement the algorithms in [<a href="../#Oh2024">1</a>] and [<a href="../#Quesada2019">2</a>] in order to be able to simulate a Gaussian boson sampling experiment with matrix-product states.</p><p>The main functions are the following.</p><ul><li><code>optimise</code> uses semi-definite programming, through the JuMP and SCS libraries, to decompose the covariance matrix of a Gaussian state into a sum of<ul><li>a pure covariance matrix which &quot;contains&quot; a smaller amount of photons,</li><li>a positive semi-definite matrix</li></ul>following the procedure detailed in [<a href="../#Oh2024">1</a>].</li><li><code>MPS</code> computes a matrix-product state that approximates a pure Gaussian state following the algorithm presented in [<a href="../#Oh2024">1</a>], by using the Franck-Condon formula from [<a href="../#Quesada2019">2</a>].</li><li><code>sample_displaced</code> samples from a state after the application of a random displacement channel.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.normal_mode_decomposition" href="#GaussianBosonSamplingMPS.normal_mode_decomposition"><code>GaussianBosonSamplingMPS.normal_mode_decomposition</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_mode_decomposition(g::GaussianState, N, maxnumber; kwargs...)</code></pre><p>Compute the normal-mode decomposition [<a href="../#Serafini2023">6</a>, Eq. (3.60) at page 47] of the Gaussian state <code>g</code> up to the <code>N</code> largest eigenvalues, calculated by considering only the <code>k</code>-particle sectors for <code>k ≤ maxnumber</code> on each mode. Return <code>vals, nums, S</code> where <code>vals</code> contains the eigenvalues in decreasing order, <code>nums</code> contains the occupation numbers of the Fock basis vector associated to the corresponding value in <code>vals</code>, and <code>S</code> is the symplectic matrix from the Williamson decomposition of <code>g</code>.</p><p>The output satisfies the following identities:</p><pre><code class="language-julia-repl hljs">julia&gt; D, S = williamson(Symmetric(g.covariance_matrix));

julia&gt; d = diag(D)[1:2:end];

julia&gt; normalmode_evs, nums, S&#39; = normal_mode_decomposition(g, N, maxnumber);

julia&gt; all(
    val == prod(normal_mode_eigenvalue(d[j], m[j]) for j in eachindex(m)) for
    (val, m) in zip(normalmode_evs, nums)
)
true

julia&gt; S == S&#39;
true</code></pre><p><strong>References</strong></p><ul><li>[<a href="../#Serafini2023">6</a>] Serafini, A. (2023)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/normal_mode_decomposition.jl#L89-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.franckcondon" href="#GaussianBosonSamplingMPS.franckcondon"><code>GaussianBosonSamplingMPS.franckcondon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">franckcondon(m, α, Wₗ, S, Wᵣ, n)
franckcondon(m, Wₗ, S, Wᵣ, n)</code></pre><p>Compute the matrix element <span>$⟨m| D(α) U(W_l) U(S) U(W_r) |n⟩$</span> according to the algorithm presented in Ref. [<a href="../#Quesada2019">2</a>]. <code>Wₗ</code>, <code>S</code> and <code>Wᵣ</code> are symplectic matrices, in particular <code>Wₗ</code> and <code>Wᵣ</code> are also orthogonal, and <code>α</code> is a complex vector (which defaults to the zero vector). If <span>$N$</span> is the number of modes of the system, then</p><ul><li><code>m</code> and <code>n</code> are tuples of <span>$N$</span> natural numbers,</li><li><code>α</code> is a vector of <span>$N$</span> complex numbers,</li><li><code>Wₗ</code>, <code>S</code> and <code>Wᵣ</code> are <span>$2N × 2N$</span> matrices.</li></ul><p><strong>References</strong></p><ul><li>[<a href="../#Quesada2019">2</a>] Quesada, N. <em>J Chem Phys</em> 150.16 (2019)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_construction.jl#L27-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ITensorMPS.MPS" href="#ITensorMPS.MPS"><code>ITensorMPS.MPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPS(g::GaussianState; maxdim, maxnumber, kwargs...)</code></pre><p>Build an MPS representation of the Gaussian state <code>g</code> with bond dimension up to <code>maxdim</code>, truncating the Fock space of each mode at the <code>maxnumber</code>-particle sector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/mps_construction.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.optimise" href="#GaussianBosonSamplingMPS.optimise"><code>GaussianBosonSamplingMPS.optimise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimise(g::GaussianState; verbose=false, scs_eps=nothing)</code></pre><p>Return <code>gₚ, W</code> where <code>gₚ</code> is a new Gaussian state and <code>W</code> is a positive semi-definite matrix such that <code>W + gₚ.covariance_matrix == g.covariance_matrix</code> and <code>gₚ</code> contains a smaller number of photons.</p><p>Set <code>verbose = true</code> to print the information provided by SCS about the optimisation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/state_optimisation.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaussianBosonSamplingMPS.sample_displaced" href="#GaussianBosonSamplingMPS.sample_displaced"><code>GaussianBosonSamplingMPS.sample_displaced</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_displaced(ψ::MPS, W; nsamples, nsamples_per_displacement, eval_atol=0, kwargs...)</code></pre><p>Apply random displacements sampled from the positive semi-definite matrix <code>W</code> to the pure state <code>ψ</code> and sample <code>nsamples</code> elements from the resulting state.</p><p>Return <code>s, αs</code> such that:</p><ul><li><code>s</code> is a matrix of <code>UInt8</code> elements such that each column is a sample drawn from the final state, with a new displacement vector for each <code>nsamples_per_displacement</code> draws. (The matrix will actually have a number of columns equal to <code>nsamples_per_displacement * floor(nsamples / nsamples_per_displacement)</code>.)</li><li><code>αs</code> is a matrix whose columns are the displacement vectors drawn from <code>W</code>, such that <code>αs[:, k]</code> is used for the samples from <code>(k-1)N</code> to <code>kN</code>, with <code>N = floor(nsamples / nsamples_per_displacement)</code>.</li></ul><p>The <code>eval_atol</code> keyword argument is used as threshold to decide whether an eigenvalue of <code>W</code> must be considered zero (usually it should be of the same order of the <code>eps</code> tolerances of the SCS optimiser).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/cf836bd36f271c473bd23b5b38ea347d1542a6e0/src/sampling.jl#L1-L19">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/borealis/">Borealis experiment »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 15 October 2025 16:14">Wednesday 15 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
