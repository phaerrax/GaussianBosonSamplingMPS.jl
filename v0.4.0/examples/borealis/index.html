<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Borealis experiment · GaussianBosonSamplingMPS</title><meta name="title" content="Borealis experiment · GaussianBosonSamplingMPS"/><meta property="og:title" content="Borealis experiment · GaussianBosonSamplingMPS"/><meta property="twitter:title" content="Borealis experiment · GaussianBosonSamplingMPS"/><meta name="description" content="Documentation for GaussianBosonSamplingMPS."/><meta property="og:description" content="Documentation for GaussianBosonSamplingMPS."/><meta property="twitter:description" content="Documentation for GaussianBosonSamplingMPS."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GaussianBosonSamplingMPS</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Borealis experiment</a><ul class="internal"><li><a class="tocitem" href="#Preparation"><span>Preparation</span></a></li><li><a class="tocitem" href="#Computing-the-covariance-matrix-of-the-final-state"><span>Computing the covariance matrix of the final state</span></a></li><li><a class="tocitem" href="#Optimisation"><span>Optimisation</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Borealis experiment</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Borealis experiment</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/phaerrax/GaussianBosonSamplingMPS.jl/blob/main/docs/src/examples/borealis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Borealis-experiment"><a class="docs-heading-anchor" href="#Borealis-experiment">Borealis experiment</a><a id="Borealis-experiment-1"></a><a class="docs-heading-anchor-permalink" href="#Borealis-experiment" title="Permalink"></a></h1><p>In this page you can learn how to combine the various methods provided by this package in order to simulate a typical boson-sampling experiment. We will refer, for the sake of concreteness, to the experiment setup described in [<a href="../../#Madsen2022">7</a>], but the simulation routine is easily adaptable: you will most likely need to change only how the input data is read and how the covariance matrix of the output state is computed.</p><h2 id="Preparation"><a class="docs-heading-anchor" href="#Preparation">Preparation</a><a id="Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Preparation" title="Permalink"></a></h2><h3 id="Package-requirements"><a class="docs-heading-anchor" href="#Package-requirements">Package requirements</a><a id="Package-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Package-requirements" title="Permalink"></a></h3><p>For the simulation we will need the <code>GaussianStates</code> and <code>LinearAlgebra</code> packages, and of course <code>GaussianBosonSamplingMPS</code>. We will also show, as an example, how to read the input and write the results with HDF5 files, so for this reason we also need to import <code>ITensorMPS</code> and <code>HDF5</code>, but in general this requirement may vary depending on how the input data is stored.</p><h3 id="Input-data"><a class="docs-heading-anchor" href="#Input-data">Input data</a><a id="Input-data-1"></a><a class="docs-heading-anchor-permalink" href="#Input-data" title="Permalink"></a></h3><p>The covariance matrix of the final state is determined by a vector of squeezing parameters, that we will call <span>$r$</span>, and a &quot;transfer matrix&quot; <span>$T$</span>, as instructed in the supplementary information of Ref. [<a href="../../#Madsen2022">7</a>]. In the data provided by the authors of the experiment, we have (for <span>$n$</span> modes) a vector of <span>$n$</span> real numbers and an <span>$n \times n$</span> complex matrix. We assume we can find them in HDF5 files whose names are stored in <code>squeezepar_file</code> and <code>Tmat_file</code>, respectively.</p><pre><code class="language-julia hljs">r = h5open(squeezepar_file) do hf
    read(hf, &quot;squeeze_parameters&quot;)
end
T = h5open(Tmat_file) do hf
    read(hf, &quot;transfer_matrix&quot;)
end</code></pre><p>Let&#39;s check that we loaded matrices of compatible sizes.</p><pre><code class="language-julia hljs">if !(length(r) == size(T, 1) == size(T, 2))
    error(&quot;sizes of r and T do not match.&quot;)
end</code></pre><h2 id="Computing-the-covariance-matrix-of-the-final-state"><a class="docs-heading-anchor" href="#Computing-the-covariance-matrix-of-the-final-state">Computing the covariance matrix of the final state</a><a id="Computing-the-covariance-matrix-of-the-final-state-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-covariance-matrix-of-the-final-state" title="Permalink"></a></h2><p>First we need to compute the squeezed vacuum state, which can be done with the <code>vacuumstate</code> and <code>squeeze!</code> functions from <code>GaussianStates</code> as follows:</p><pre><code class="language-julia hljs">n = length(r)
g0 = vacuumstate(n)
squeeze!(g0, r)</code></pre><p>then we apply the transfer matrix. The matrix from the Borealis experiment comes as an <span>$n \times n$</span> complex matrix, while we need a <span>$2n \times 2n$</span> real matrix that can be multiplied with the covariance matrix. Let&#39;s call <span>$\phi_T$</span> this new, larger matrix. With the <code>xxpp</code> notation for moments of Gaussian states, <span>$\phi_T$</span> would simply be</p><p class="math-container">\[\begin{pmatrix}
  \real T &amp; -\imag T\\
  \imag T &amp; \real T
\end{pmatrix}\]</p><p>but since the <code>GaussianStates</code> package uses the <code>xpxp</code> notation we need to permute its rows and columns: this can be easily done by calling <code>GaussianStates.permute_to_xpxp</code>. In the end, we get our matrix as</p><pre><code class="language-julia hljs">ϕT = GaussianStates.permute_to_xpxp([
    real(T) -imag(T)
    imag(T) real(T)
])</code></pre><p>The covariance matrix of the final state can then be obtained, from the covariance matrix <span>$\sigma_{r}$</span> of the squeezed vacuum state, by the formula</p><p class="math-container">\[\sigma = I_{2n} - \phi_T \transpose{\phi_T} + \phi_T \sigma_{r}
\transpose{\phi_T}\]</p><p>so we can build our final Gaussian state with</p><pre><code class="language-julia hljs">σ = I - ϕT * ϕT&#39; + ϕT * g0.covariance_matrix * ϕT&#39;
g = GaussianState(Symmetric(σ))</code></pre><p>which defines a Gaussian state with null first moments and the given covariance matrix. We know that <code>σ</code> is symmetric, but due to some numerical errors it may not be so, thus we also call <code>Symmetric</code> on it in order to make it <em>truly</em> symmetric: this way Julia can later choose to use methods that are specific to symmetric matrices, that can be more efficient.</p><h2 id="Optimisation"><a class="docs-heading-anchor" href="#Optimisation">Optimisation</a><a id="Optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#Optimisation" title="Permalink"></a></h2><p>Here comes the optimisation part, where we rely on the SCS solver through the <code>optimise</code> function from this package. We can choose its precision by adjusting the <code>scs_eps</code> keyword argument.</p><pre><code class="language-julia hljs">scs_eps = 1e-8
g_opt, W = optimise(g; scs_eps=scs_eps)</code></pre><p>Now we have <code>g_opt</code>, a new Gaussian state which contains (as long as <span>$T$</span> is not unitary) fewer photons than the previous state, and <code>W</code>, a positive semi-definite matrix that will represent a random displacement channel.</p><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>The ground-truth probability distribution of the boson-sampling experiment is the function [<a href="../../#Oh2024">1</a>, Eq. (6)]</p><p class="math-container">\[p(m) = \int_{\R^{2n}} p_W(\alpha) p_{g\opt}(m \mid \alpha) \, \dd\alpha,\]</p><p>where</p><p class="math-container">\[p_W(x) = \frac{1}{(2\pi)^n \sqrt{\det W}} \, \exp\bigl(-\tfrac12
\transpose{x} W^{-1} x\bigr)\]</p><p>is a multivariate normal probability density with mean zero and covariance matrix <span>$W$</span>, and <span>$p_{g\opt}(m \mid \alpha)$</span> is the probability of getting a Fock state with occupation numbers <span>$m \in \N^{2n}$</span> from the <span>$g\opt$</span> state. For the purposes of these functions the displacement vector, originally <span>$\alpha \in \C^n$</span> is seen as the vector</p><p class="math-container">\[(\real\alpha_1, \imag\alpha_1, \real\alpha_2,
\imag\alpha_2, \dotsc, \real\alpha_n, \imag\alpha_n) \in \R^{2n}``.\]</p><h3 id="MPS-creation"><a class="docs-heading-anchor" href="#MPS-creation">MPS creation</a><a id="MPS-creation-1"></a><a class="docs-heading-anchor-permalink" href="#MPS-creation" title="Permalink"></a></h3><p>The first thing we need to do is to approximate <code>g_opt</code> with a matrix-product state: to do this, we call the <code>MPS</code> function on the Gaussian state as follows:</p><pre><code class="language-julia hljs">v = MPS(g_opt; maxdim=10, maxnumber=4, purity_atol=10*scs_eps)</code></pre><p>We need to specify the (maximum) bond dimension of the MPS, <code>maxdim</code>, as well as the dimension of the local Hilbert space by setting the maximum allowed occupation number <code>maxnumber</code> (the dimension will be <code>maxnumber</code> plus one).</p><div class="admonition is-warning" id="Keep-the-local-dimension-low-d91c3a99fdfa6695"><header class="admonition-header">Keep the local dimension low<a class="admonition-anchor" href="#Keep-the-local-dimension-low-d91c3a99fdfa6695" title="Permalink"></a></header><div class="admonition-body"><p>As the Franck-Condon formula in Ref. [<a href="../../#Quesada2019">2</a>] involves the calculation of factorials of numbers up to the local dimension, it is recommended to choose a relatively low <code>maxnumber</code>. The authors in Ref. [<a href="../../#Oh2024">1</a>] report that <code>maxnumber = 4</code> is enough, at this stage of the calculations, to obtain sensible results.</p></div></div><div class="admonition is-info" id="Tolerance-for-intermediate-checks-720954edb705b895"><header class="admonition-header">Tolerance for intermediate checks<a class="admonition-anchor" href="#Tolerance-for-intermediate-checks-720954edb705b895" title="Permalink"></a></header><div class="admonition-body"><p>The optional <code>purity_atol</code> argument can be passed to the function in order to adjust the tolerance of some intermediate checks, which assume that the input Gaussian state is pure. The optimisation routine however does not output a perfectly pure state: mainly, some of its symplectic eigenvalues may be less than 1, usually by the same order as <code>scs_eps</code>. A positive <code>purity_atol</code> value can be used to make these checks less strict.</p></div></div><p>Now is a good time to save the intermediate results, before going on to the sampling stage. This is an example of how we can bundle the initial data and the MPS of the optimised Gaussian state in an HDF5 file: if <code>outputfile</code> contains the name of the output file,</p><pre><code class="language-julia hljs">h5open(outputfile, &quot;w&quot;) do hf
    write(hf, &quot;squeeze_parameters&quot;, r)
    write(hf, &quot;transfer_matrix&quot;, T)
    write(hf, &quot;final_state&quot;, v)
end</code></pre><h3 id="Application-of-random-displacements"><a class="docs-heading-anchor" href="#Application-of-random-displacements">Application of random displacements</a><a id="Application-of-random-displacements-1"></a><a class="docs-heading-anchor-permalink" href="#Application-of-random-displacements" title="Permalink"></a></h3><p>Before applying the displacement operators, we first need to increase the local dimensions of the Hilbert spaces. These operators are local, they consist in taking a linear combination of the matrices on each site separately, therefore it is a very efficient operation given the MPS form of the state, regardless of the local dimension. However, the displacement may increase the (local) mean number of photons, therefore we need a larger Hilbert space in order to faithfully represent the displaced state. This can be done by using the <code>enlargelocaldim</code> function: here we increase the local dimension, uniformly, to 100.</p><pre><code class="language-julia hljs">v = enlargelocaldim(v, 100)</code></pre><p>Finally, we use the <code>sample_displaced</code> function to sample from the probability distribution <span>$p$</span> defined above:</p><pre><code class="language-julia hljs">samples, displacements = sample_displaced(
    v,
    W;
    nsamples=1000,
    nsamples_per_displacement=10,
    eval_atol=10*scs_eps,
)</code></pre><p>This function draws a displacement vector from <span>$p_W$</span>, applies such displacement to the state then samples from it a certain number of times; then, it draws a new displacement vector, and so on. We decide now many samples we want (in total) with <code>nsamples</code>, while <code>nsamples_per_displacement</code> controls how many samples are drawn for each displacement vector.</p><div class="admonition is-info" id="Info-847fa9cfaaeacd9d"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-847fa9cfaaeacd9d" title="Permalink"></a></header><div class="admonition-body"><p>If <code>nsamples</code> is not a multiple of <code>nsamples_per_displacement</code> then we will actually get <code>nsamples_per_displacement * floor(nsamples / nsamples_per_displacement)</code> total samples.</p></div></div><p>Once the sampling routine is over, <code>samples</code> is a matrix of natural numbers whose columns are the samples, corresponding to the multiindices <span>$m$</span> in the equations above; <code>displacements</code> is a complex matrix whose columns are the displacement vectors sampled from <span>$W$</span>.</p><div class="admonition is-info" id="Tolerance-for-negative-eigenvalues-f23cb7c941912ec9"><header class="admonition-header">Tolerance for negative eigenvalues<a class="admonition-anchor" href="#Tolerance-for-negative-eigenvalues-f23cb7c941912ec9" title="Permalink"></a></header><div class="admonition-body"><p>As with the <span>$g\opt$</span> Gaussian state, the <span>$W$</span> matrix may end up not being positive semi-definite due to the finite working precision of the optimisation routine: usually it has some positive and negative eigenvalues of the order of <code>scs_eps</code> which should instead be zero (you can see that they get closer and closer to zero as you decrease <code>scs_eps</code>). Since the normal multivariate distribution cannot be defined if <span>$W$</span> is not positive semi-definite, the <code>eval_atol</code> parameter can be adjusted to replace all eigenvalues smaller than this threshold to zero.</p></div></div><p>Now the simulation is complete: we can append the results to the HDF5 file we created previously by doing</p><pre><code class="language-julia hljs">h5open(outputfile, &quot;cw&quot;) do hf
    write(hf, &quot;displacements&quot;, displacements)
    write(hf, &quot;samples&quot;, samples)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../reference/">« Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 15 October 2025 16:14">Wednesday 15 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
