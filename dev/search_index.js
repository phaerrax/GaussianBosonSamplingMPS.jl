var documenterSearchIndex = {"docs":
[{"location":"examples/borealis/#Borealis-experiment","page":"Borealis experiment","title":"Borealis experiment","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"In this page you can learn how to combine the various methods provided by this package in order to simulate a typical boson-sampling experiment. We will refer, for the sake of concreteness, to the experiment setup described in [6], but the simulation routine is easily adaptable: you will most likely need to change only how the input data is read and how the covariance matrix of the output state is computed.","category":"page"},{"location":"examples/borealis/#Preparation","page":"Borealis experiment","title":"Preparation","text":"","category":"section"},{"location":"examples/borealis/#Package-requirements","page":"Borealis experiment","title":"Package requirements","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"For the simulation we will need the GaussianStates and LinearAlgebra packages, and of course GaussianBosonSamplingMPS. We will also show, as an example, how to read the input and write the results with HDF5 files, so for this reason we also need to import ITensorMPS and HDF5, but in general this requirement may vary depending on how the input data is stored.","category":"page"},{"location":"examples/borealis/#Input-data","page":"Borealis experiment","title":"Input data","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"The covariance matrix of the final state is determined by a vector of squeezing parameters, that we will call r, and a \"transfer matrix\" T, as instructed in the supplementary information of Ref. [6]. In the data provided by the authors of the experiment, we have (for n modes) a vector of n real numbers and an n times n complex matrix. We assume we can find them in HDF5 files whose names are stored in squeezepar_file and Tmat_file, respectively.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"r = h5open(squeezepar_file) do hf\n    read(hf, \"squeeze_parameters\")\nend\nT = h5open(Tmat_file) do hf\n    read(hf, \"transfer_matrix\")\nend","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Let's check that we loaded matrices of compatible sizes.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"if !(length(r) == size(T, 1) == size(T, 2))\n    error(\"sizes of r and T do not match.\")\nend","category":"page"},{"location":"examples/borealis/#Computing-the-covariance-matrix-of-the-final-state","page":"Borealis experiment","title":"Computing the covariance matrix of the final state","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"First we need to compute the squeezed vacuum state, which can be done with the vacuumstate and squeeze! functions from GaussianStates as follows:","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"n = length(r)\ng0 = vacuumstate(n)\nsqueeze!(g0, r)","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"then we apply the transfer matrix. The matrix from the Borealis experiment comes as an n times n complex matrix, while we need a 2n times 2n real matrix that can be multiplied with the covariance matrix. Let's call phi_T this new, larger matrix. With the xxpp notation for moments of Gaussian states, phi_T would simply be","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"beginpmatrix\n  real T  -imag T\n  imag T  real T\nendpmatrix","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"but since the GaussianStates package uses the xpxp notation we need to permute its rows and columns: this can be easily done by calling GaussianStates.permute_to_xpxp. In the end, we get our matrix as","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"ϕT = GaussianStates.permute_to_xpxp([\n    real(T) -imag(T)\n    imag(T) real(T)\n])","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"The covariance matrix of the final state can then be obtained, from the covariance matrix sigma_r of the squeezed vacuum state, by the formula","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"sigma = I_2n - phi_T transposephi_T + phi_T sigma_r\ntransposephi_T","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"so we can build our final Gaussian state with","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"σ = I - ϕT * ϕT' + ϕT * g0.covariance_matrix * ϕT'\ng = GaussianState(Symmetric(σ))","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"which defines a Gaussian state with null first moments and the given covariance matrix. We know that σ is symmetric, but due to some numerical errors it may not be so, thus we also call Symmetric on it in order to make it truly symmetric: this way Julia can later choose to use methods that are specific to symmetric matrices, that can be more efficient.","category":"page"},{"location":"examples/borealis/#Optimisation","page":"Borealis experiment","title":"Optimisation","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Here comes the optimisation part, where we rely on the SCS solver through the optimise function from this package. We can choose its precision by adjusting the scs_eps keyword argument.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"scs_eps = 1e-8\ng_opt, W = optimise(g; scs_eps=scs_eps)","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Now we have g_opt, a new Gaussian state which contains (as long as T is not unitary) fewer photons than the previous state, and W, a positive semi-definite matrix that will represent a random displacement channel.","category":"page"},{"location":"examples/borealis/#Sampling","page":"Borealis experiment","title":"Sampling","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"The ground-truth probability distribution of the boson-sampling experiment is the function [1, Eq. (6)]","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"p(m) = int_R^2n p_W(alpha) p_gopt(m mid alpha)  ddalpha","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"where","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"p_W(x) = frac1(2pi)^n sqrtdet W  expbigl(-tfrac12\ntransposex W^-1 xbigr)","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"is a multivariate normal probability density with mean zero and covariance matrix W, and p_gopt(m mid alpha) is the probability of getting a Fock state with occupation numbers m in N^2n from the gopt state. For the purposes of these functions the displacement vector, originally alpha in C^n is seen as the vector","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"(realalpha_1 imagalpha_1 realalpha_2\nimagalpha_2 dotsc realalpha_n imagalpha_n) in R^2n","category":"page"},{"location":"examples/borealis/#MPS-creation","page":"Borealis experiment","title":"MPS creation","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"The first thing we need to do is to approximate g_opt with a matrix-product state: to do this, we call the MPS function on the Gaussian state as follows:","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"v = MPS(g_opt; maxdim=10, maxnumber=4, purity_atol=10*scs_eps)","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"We need to specify the (maximum) bond dimension of the MPS, maxdim, as well as the dimension of the local Hilbert space by setting the maximum allowed occupation number maxnumber (the dimension will be maxnumber plus one).","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"warning: Keep the local dimension low\nAs the Franck-Condon formula in Ref. [2] involves the calculation of factorials of numbers up to the local dimension, it is recommended to choose a relatively low maxnumber. The authors in Ref. [1] report that maxnumber = 4 is enough, at this stage of the calculations, to obtain sensible results.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"info: Tolerance for intermediate checks\nThe optional purity_atol argument can be passed to the function in order to adjust the tolerance of some intermediate checks, which assume that the input Gaussian state is pure. The optimisation routine however does not output a perfectly pure state: mainly, some of its symplectic eigenvalues may be less than 1, usually by the same order as scs_eps. A positive purity_atol value can be used to make these checks less strict.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Now is a good time to save the intermediate results, before going on to the sampling stage. This is an example of how we can bundle the initial data and the MPS of the optimised Gaussian state in an HDF5 file: if outputfile contains the name of the output file,","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"h5open(outputfile, \"w\") do hf\n    write(hf, \"squeeze_parameters\", r)\n    write(hf, \"transfer_matrix\", T)\n    write(hf, \"final_state\", v)\nend","category":"page"},{"location":"examples/borealis/#Application-of-random-displacements","page":"Borealis experiment","title":"Application of random displacements","text":"","category":"section"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Before applying the displacement operators, we first need to increase the local dimensions of the Hilbert spaces. These operators are local, they consist in taking a linear combination of the matrices on each site separately, therefore it is a very efficient operation given the MPS form of the state, regardless of the local dimension. However, the displacement may increase the (local) mean number of photons, therefore we need a larger Hilbert space in order to faithfully represent the displaced state. This can be done by using the enlargelocaldim function: here we increase the local dimension, uniformly, to 100.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"v = enlargelocaldim(v, 100)","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Finally, we use the sample_displaced function to sample from the probability distribution p defined above:","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"samples, displacements = sample_displaced(\n    v,\n    W;\n    nsamples=1000,\n    nsamples_per_displacement=10,\n    eval_atol=10*scs_eps,\n)","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"This function draws a displacement vector from p_W, applies such displacement to the state then samples from it a certain number of times; then, it draws a new displacement vector, and so on. We decide now many samples we want (in total) with nsamples, while nsamples_per_displacement controls how many samples are drawn for each displacement vector.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"info: Info\nIf nsamples is not a multiple of nsamples_per_displacement then we will actually get nsamples_per_displacement * floor(nsamples / nsamples_per_displacement) total samples.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Once the sampling routine is over, samples is a matrix of natural numbers whose columns are the samples, corresponding to the multiindices m in the equations above; displacements is a complex matrix whose columns are the displacement vectors sampled from W.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"info: Tolerance for negative eigenvalues\nAs with the gopt Gaussian state, the W matrix may end up not being positive semi-definite due to the finite working precision of the optimisation routine: usually it has some positive and negative eigenvalues of the order of scs_eps which should instead be zero (you can see that they get closer and closer to zero as you decrease scs_eps). Since the normal multivariate distribution cannot be defined if W is not positive semi-definite, the eval_atol parameter can be adjusted to replace all eigenvalues smaller than this threshold to zero.","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"Now the simulation is complete: we can append the results to the HDF5 file we created previously by doing","category":"page"},{"location":"examples/borealis/","page":"Borealis experiment","title":"Borealis experiment","text":"h5open(outputfile, \"cw\") do hf\n    write(hf, \"displacements\", displacements)\n    write(hf, \"samples\", samples)\nend","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Superboson-matrix-product-states","page":"Reference","title":"Superboson matrix-product states","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The package introduces a new type, called SuperBosonMPS, which is basically an ordinary MPS from ITensors with some additional decoration. This MPS represents a generic mixed state in a many-body bosonic Fock space using the superboson formalism [4], which translates mixed states to pure states in an enlarged Hilbert space.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"It is a subtype of AbstractMPS, therefore you can use most of the methods already defined by ITensors on the SuperBosonMPS type too.","category":"page"},{"location":"reference/#Constructors","page":"Reference","title":"Constructors","text":"","category":"section"},{"location":"reference/#GaussianBosonSamplingMPS.SuperBosonMPS","page":"Reference","title":"GaussianBosonSamplingMPS.SuperBosonMPS","text":"SuperBosonMPS\n\nA finite-size matrix-product state type that represents mixed states in the superboson formalism [4].\n\nReferences\n\n[4] Schmutz, M. Z Physik B 30, 97–106 (1978)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Utility-functions","page":"Reference","title":"Utility functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"To make working with a superboson space easier, this library provides the following utilities.","category":"page"},{"location":"reference/#GaussianStates.nmodes","page":"Reference","title":"GaussianStates.nmodes","text":"nmodes(v::SuperBosonMPS)\n\nReturn the number of \"true\" bosonic modes contained in the SuperBosonMPS v, i.e. half its actual length.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.enlargelocaldim","page":"Reference","title":"GaussianBosonSamplingMPS.enlargelocaldim","text":"enlargelocaldim(v::AbstractMPS, newdim)\n\nReturn a new MPS with the local dimension increased to newdim.\n\nNote that the new MPS will be defined on a new set of site indices, so it will be incompatible with the original one.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.sb_siteinds","page":"Reference","title":"GaussianBosonSamplingMPS.sb_siteinds","text":"sb_siteinds(; nmodes, maxnumber)\n\nReturn a list of ITensor site indices suited to define a superbosonic state, with alternating \"physical\" and \"ancillary\" sites.\n\nKeyword arguments (mandatory)\n\nnmodes: the number of \"real-world\" bosonic modes of the system (the actual MPS will have 2nmodes sites).\nmaxnumber: maximum number of bosons allowed on each site. The local Hilbert spaces will be truncated to a dimension of maxnumber+1.\n\nExample\n\njulia> sb_siteinds(; nmodes=2, maxnumber=4)\n4-element Vector{Index{Int64}}:\n (dim=5|id=962|\"Boson,Site,n=1,phy\")\n (dim=5|id=41|\"Boson,Site,anc,n=1\")\n (dim=5|id=794|\"Boson,Site,n=2,phy\")\n (dim=5|id=198|\"Boson,Site,anc,n=2\")\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.sb_outer","page":"Reference","title":"GaussianBosonSamplingMPS.sb_outer","text":"sb_outer(ψ::MPS)\n\nCompute the projection operator ψψ  ψ², from the MPS ψ representing a pure state, returning a SuperBosonMPS object (of double the size).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expectation-values-and-sampling","page":"Reference","title":"Expectation values and sampling","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"To extract physical information from a SuperBosonMPS object, you can use the expect, correlation_matrix and sample functions, which work exactly as in the ITensorMPS library.","category":"page"},{"location":"reference/#ITensorMPS.expect","page":"Reference","title":"ITensorMPS.expect","text":"expect(v::SuperBosonMPS, op::AbstractString...; kwargs...)\nexpect(v::SuperBosonMPS, op::Matrix{<:Number}...; kwargs...)\nexpect(v::SuperBosonMPS, ops; kwargs...)\n\nGiven a superbosonic MPS v and a single operator name or matrix, returns a vector of the expected value of the operator on each site of the SuperBosonMPS.\n\nIf multiple operator names are provided, returns a tuple of expectation value vectors.\n\nIf a container of operator names is provided, returns the same type of container with names replaced by vectors of expectation values.\n\nOptional keyword arguments\n\nsites = 1:nmodes(v): compute expected values only for modes in the given range\n\nExamples\n\nN = 10\n\ns = sb_siteinds(\"Boson\", N)\nv = sb_outer(random_mps(s; linkdims=4))\nexpect(v, \"N\")  # compute for all sites\nexpect(v, \"N\"; sites=2:4)  # compute for sites 2, 3 and 4\nexpect(v, \"N\"; sites=3)  # compute for site 3 only (output will be a scalar)\nexpect(v, [\"A*Adag\", \"N\"])  # compute A*Adag and N for all sites\nexpect(v, [0 0; 0 1])  # same as expect(v, \"N\") if maxnumber == 1\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorMPS.correlation_matrix","page":"Reference","title":"ITensorMPS.correlation_matrix","text":"correlation_matrix(\n    v::SuperBosonMPS, A::AbstractString, B::AbstractString; kwargs...\n)\n\ncorrelation_matrix(\n    v::SuperBosonMPS, A::Matrix{<:Number}, B::Matrix{<:Number}; kwargs...\n)\n\nGiven a SuperBosonMPS v representing a state ρ and two strings or matrices A and B denoting operators (as recognized by the op function), computes the two-point correlation function matrix C_ij = textrmtr(A_i B_j ρ) using efficient MPS techniques. Returns the matrix C.\n\nOptional keyword arguments\n\nsites = 1:nmodes(v): compute correlations only for sites in the given range\nishermitian = false : if false, force independent calculations of the matrix elements above and below the diagonal, while if true assume they are complex conjugates.\n\nExamples\n\njulia> s = siteinds(\"Boson\", 3; dim=4);\n\njulia> vac = sb_outer(MPS(ComplexF64, s, \"0\"));\n\njulia> correlation_matrix(vac, \"x\", \"x\")\n3×3 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im  0.0+0.0im\n 0.0-0.0im  0.5+0.0im  0.0+0.0im\n 0.0-0.0im  0.0-0.0im  0.5+0.0im\n\njulia> correlation_matrix(vac, \"p\", \"x\")\n3×3 Matrix{ComplexF64}:\n 0.0-0.5im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0-0.5im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0-0.5im\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorMPS.sample","page":"Reference","title":"ITensorMPS.sample","text":"sample(m::SuperBosonMPS)\n\nGiven a \"superbosonic\" MPS m with unit trace, compute a Vector{Int} of nmodes(m) elements corresponding to one sample of the probability distribution defined by the components of the density matrix that the MPS represents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gaussian-states-and-operations","page":"Reference","title":"Gaussian states and operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"This package works in tandem with the GaussianStates package, extending some of its methods to define them on matrix-product states (both ordinary and superbosonic ones).","category":"page"},{"location":"reference/#First-and-second-moments","page":"Reference","title":"First and second moments","text":"","category":"section"},{"location":"reference/#GaussianBosonSamplingMPS.firstmoments","page":"Reference","title":"GaussianBosonSamplingMPS.firstmoments","text":"firstmoments(v; warn_atol=1e-14)\n\nCompute the first moments of the state v; return a vector in the xpxp order, i.e. the vector (x_1 p_1 x_2 p_2  x_N p_N).\n\nThe warn_atol keyword argument can be used to adjust the threshold used by the function to warn when the moments are not real.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.covariancematrix","page":"Reference","title":"GaussianBosonSamplingMPS.covariancematrix","text":"covariancematrix(v; warn_atol=1e-14)\n\nCompute the covariance matrix of the state v, in the xpxp order.\n\nThe warn_atol keyword argument can be used to adjust the threshold used by the function to warn when the moments are not real.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gaussian-operations","page":"Reference","title":"Gaussian operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following methods can be applied to an MPS in order to simulate quantum optical operations.","category":"page"},{"location":"reference/#GaussianBosonSamplingMPS.attenuate","page":"Reference","title":"GaussianBosonSamplingMPS.attenuate","text":"attenuate(v::SuperBosonMPS, attenuation, n)\n\nApply on mode n the attenuator channel ρ  sum_k=0^+ B_k ρ adjB_k on the MPS v representing the state ρ in the superboson formalism, where\n\nB_k = sum_m=0^+ binomm+kk^frac12 (1-η^2)^frack2 η^m mm+k\n\nand η is the attenuation coefficient, such that sum_k=0^+infty B_k ρ adjB_k is equal to 00 when η = 0 and to ρ when η = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.displace","page":"Reference","title":"GaussianStates.displace","text":"displace(m::MPS, α; kwargs...)\n\nApply a product of single-mode displacement operators on the pure state represented by the MPS m, with parameter α[j] on mode j.\n\n\n\n\n\ndisplace(v::MPS, α; kwargs...)\n\nApply a product of single-mode displacement operators, with parameter α[j] on mode j, on the mixed state represented by the SuperBosonMPS v in the superboson formalism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.squeeze","page":"Reference","title":"GaussianStates.squeeze","text":"squeeze(v::SuperBosonMPS, n, z; kwargs...)\n\nApply the squeezing operator with parameter z on mode n to the state represented by v.\n\n\n\n\n\nsqueeze(v::SuperBosonMPS, z; kwargs...)\n\nApply the squeezing operator with parameter z_i on each mode i to the state represented by v.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.beamsplitter","page":"Reference","title":"GaussianStates.beamsplitter","text":"beamsplitter(v::SuperBosonMPS, transmittivity, n1, n2; kwargs...)\n\nApply a beam-splitter operator on modes n1 and n2 with given transmittivity to the state represented by v.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Boson-sampling-output-simulation","page":"Reference","title":"Boson sampling output simulation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Here lies the heart of this package: the following methods implement the algorithms in [1] and [2] in order to be able to simulate a Gaussian boson sampling experiment with matrix-product states.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The main functions are the following.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"optimise uses semi-definite programming, through the JuMP and SCS libraries, to decompose the covariance matrix of a Gaussian state into a sum of\na pure covariance matrix which \"contains\" a smaller amount of photons,\na positive semi-definite matrix\nfollowing the procedure detailed in [1].\nMPS computes a matrix-product state that approximates a pure Gaussian state following the algorithm presented in [1], by using the Franck-Condon formula from [2].\nsample_displaced samples from a state after the application of a random displacement channel.","category":"page"},{"location":"reference/#GaussianBosonSamplingMPS.normal_mode_decomposition","page":"Reference","title":"GaussianBosonSamplingMPS.normal_mode_decomposition","text":"normal_mode_decomposition(g::GaussianState, N, maxnumber; kwargs...)\n\nCompute the normal-mode decomposition [5, Eq. (3.60) at page 47] of the Gaussian state g up to the N largest eigenvalues, calculated by considering only the k-particle sectors for k ≤ maxnumber on each mode. Return vals, nums, S where vals contains the eigenvalues in decreasing order, nums contains the occupation numbers of the Fock basis vector associated to the corresponding value in vals, and S is the symplectic matrix from the Williamson decomposition of g.\n\nThe output satisfies the following identities:\n\njulia> D, S = williamson(Symmetric(g.covariance_matrix));\n\njulia> d = diag(D)[1:2:end];\n\njulia> normalmode_evs, nums, S' = normal_mode_decomposition(g, N, maxnumber);\n\njulia> all(\n    val == prod(normal_mode_eigenvalue(d[j], m[j]) for j in eachindex(m)) for\n    (val, m) in zip(normalmode_evs, nums)\n)\ntrue\n\njulia> S == S'\ntrue\n\nReferences\n\n[5] Serafini, A. (2023)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.franckcondon","page":"Reference","title":"GaussianBosonSamplingMPS.franckcondon","text":"franckcondon(m, α, Wₗ, S, Wᵣ, n)\nfranckcondon(m, Wₗ, S, Wᵣ, n)\n\nCompute the matrix element m D(α) U(W_l) U(S) U(W_r) n according to the algorithm presented in Ref. [2]. Wₗ, S and Wᵣ are symplectic matrices, in particular Wₗ and Wᵣ are also orthogonal, and α is a complex vector (which defaults to the zero vector). If N is the number of modes of the system, then\n\nm and n are tuples of N natural numbers,\nα is a vector of N complex numbers,\nWₗ, S and Wᵣ are 2N  2N matrices.\n\nReferences\n\n[2] Quesada, N. J Chem Phys 150.16 (2019)\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorMPS.MPS","page":"Reference","title":"ITensorMPS.MPS","text":"MPS(g::GaussianState; maxdim, maxnumber, kwargs...)\n\nBuild an MPS representation of the Gaussian state g with bond dimension up to maxdim, truncating the Fock space of each mode at the maxnumber-particle sector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GaussianBosonSamplingMPS.optimise","page":"Reference","title":"GaussianBosonSamplingMPS.optimise","text":"optimise(g::GaussianState; verbose=false, scs_eps=nothing)\n\nReturn gₚ, W where gₚ is a new Gaussian state and W is a positive semi-definite matrix such that W + gₚ.covariance_matrix == g.covariance_matrix and gₚ contains a smaller number of photons.\n\nSet verbose = true to print the information provided by SCS about the optimisation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.sample_displaced","page":"Reference","title":"GaussianBosonSamplingMPS.sample_displaced","text":"sample_displaced(ψ::MPS, W; nsamples, nsamples_per_displacement, eval_atol=0, kwargs...)\n\nApply random displacements sampled from the positive semi-definite matrix W to the pure state ψ and sample nsamples elements from the resulting state.\n\nReturn s, αs such that:\n\ns is a matrix of UInt8 elements such that each column is a sample drawn from the final state, with a new displacement vector for each nsamples_per_displacement draws. (The matrix will actually have a number of columns equal to nsamples_per_displacement * floor(nsamples / nsamples_per_displacement).)\nαs is a matrix whose columns are the displacement vectors drawn from W, such that αs[:, k] is used for the samples from (k-1)N to kN, with N = floor(nsamples / nsamples_per_displacement).\n\nThe eval_atol keyword argument is used as threshold to decide whether an eigenvalue of W must be considered zero (usually it should be of the same order of the eps tolerances of the SCS optimiser).\n\n\n\n\n\n","category":"function"},{"location":"#GaussianBosonSamplingMPS.jl","page":"Home","title":"GaussianBosonSamplingMPS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for the GaussianBosonSamplingMPS.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements the tensor-network-based algorithm for simulating Gaussian boson sampling experiments proposed in [1], and of the algorithm in [2] for computing elements of Gaussian operations in the Fock number basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions for computing hafnians and loop hafnians of square matrices are ported from The Walrus [3].","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulate a linear optical quantum computer with matrix-product states (MPS) through the application of common operations such as one- and two-mode squeezing, beam splitters, etc. and also simulate losses through an attenuator channel.\nManipulate MPS (and sample from them) representing mixed states in the superboson formalism [4].\nFind an approximate MPS representation of a Gaussian state in the Fock basis.\nSample from the outcome of a lossy Gaussian boson sampling experiment with the classical MPS-based algorithm described in [1].","category":"page"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"C. Oh, M. Liu, Y. Alexeev, B. Fefferman and L. Jiang. Classical algorithm for simulating experimental Gaussian boson sampling. Nature Physics 20, 1461–1468 (2024).\n\n\n\nN. Quesada. Franck-Condon factors by counting perfect matchings of graphs with loops. The Journal of Chemical Physics 150, 164113–164113 (2019).\n\n\n\nB. Gupt, J. Izaac and N. Quesada. The Walrus: a library for the calculation of hafnians, Hermite polynomials and Gaussian boson sampling. Journal of Open Source Software 4, 1705 (2019).\n\n\n\nM. Schmutz. Real-time Green's functions in many body problems. Zeitschrift für Physik B Condensed Matter 30, 97–106 (1978).\n\n\n\nA. Serafini. Quantum Continuous Variables (CRC Press, 2023).\n\n\n\nL. Madsen, F. Laudenbach, M. Askarani, F. Rortais, T. Vincent, J. Bulmer, F. Miatto, L. Neuhaus, L. Helt, M. Collins, A. Lita, T. Gerrits, S. Nam, V. Vaidya, M. Menotti, I. Dhand, Z. Vernon, N. Quesada and J. Lavoie. Quantum computational advantage with a programmable photonic processor. Nature 606, 75–81 (2022).\n\n\n\n","category":"page"}]
}
