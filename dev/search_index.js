var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Superboson-matrix-product-states","page":"Reference","title":"Superboson matrix-product states","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The package introduces a new type, called SuperBosonMPS, which is basically an ordinary MPS from ITensors with some additional decoration. This MPS represents a generic mixed state in a many-body bosonic Fock space using the superboson formalism [4], which translates mixed states to pure states in an enlarged Hilbert space.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"It is a subtype of AbstractMPS, therefore you can use most of the methods already defined by ITensors on the SuperBosonMPS type too.","category":"page"},{"location":"reference/#Constructors","page":"Reference","title":"Constructors","text":"","category":"section"},{"location":"reference/#GaussianBosonSamplingMPS.SuperBosonMPS","page":"Reference","title":"GaussianBosonSamplingMPS.SuperBosonMPS","text":"SuperBosonMPS\n\nA finite-size matrix-product state type that represents mixed states in the superboson formalism [4].\n\nReferences\n\n[4] Schmutz, M. Z Physik B 30, 97–106 (1978)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Utility-functions","page":"Reference","title":"Utility functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"To make working with a superboson space easier, this library provides the following utilities.","category":"page"},{"location":"reference/#GaussianStates.nmodes","page":"Reference","title":"GaussianStates.nmodes","text":"nmodes(v::SuperBosonMPS)\n\nReturn the number of \"true\" bosonic modes contained in the SuperBosonMPS v, i.e. half its actual length.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.enlargelocaldim","page":"Reference","title":"GaussianBosonSamplingMPS.enlargelocaldim","text":"enlargelocaldim(v::AbstractMPS, newdim)\n\nReturn a new MPS with the local dimension increased to newdim.\n\nNote that the new MPS will be defined on a new set of site indices, so it will be incompatible with the original one.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.sb_siteinds","page":"Reference","title":"GaussianBosonSamplingMPS.sb_siteinds","text":"sb_siteinds(; nmodes, maxnumber)\n\nReturn a list of ITensor site indices suited to define a superbosonic state, with alternating \"physical\" and \"ancillary\" sites.\n\nKeyword arguments (mandatory)\n\nnmodes: the number of \"real-world\" bosonic modes of the system (the actual MPS will have 2nmodes sites).\nmaxnumber: maximum number of bosons allowed on each site. The local Hilbert spaces will be truncated to a dimension of maxnumber+1.\n\nExample\n\njulia> sb_siteinds(; nmodes=2, maxnumber=4)\n4-element Vector{Index{Int64}}:\n (dim=5|id=962|\"Boson,Site,n=1,phy\")\n (dim=5|id=41|\"Boson,Site,anc,n=1\")\n (dim=5|id=794|\"Boson,Site,n=2,phy\")\n (dim=5|id=198|\"Boson,Site,anc,n=2\")\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.sb_outer","page":"Reference","title":"GaussianBosonSamplingMPS.sb_outer","text":"sb_outer(ψ::MPS)\n\nCompute the projection operator ψψ  ψ², from the MPS ψ representing a pure state, returning a SuperBosonMPS object (of double the size).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expectation-values-and-sampling","page":"Reference","title":"Expectation values and sampling","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"To extract physical information from a SuperBosonMPS object, you can use the expect, correlation_matrix and sample functions, which work exactly as in the ITensorMPS library.","category":"page"},{"location":"reference/#ITensorMPS.expect","page":"Reference","title":"ITensorMPS.expect","text":"expect(v::SuperBosonMPS, op::AbstractString...; kwargs...)\nexpect(v::SuperBosonMPS, op::Matrix{<:Number}...; kwargs...)\nexpect(v::SuperBosonMPS, ops; kwargs...)\n\nGiven a superbosonic MPS v and a single operator name or matrix, returns a vector of the expected value of the operator on each site of the SuperBosonMPS.\n\nIf multiple operator names are provided, returns a tuple of expectation value vectors.\n\nIf a container of operator names is provided, returns the same type of container with names replaced by vectors of expectation values.\n\nOptional keyword arguments\n\nsites = 1:nmodes(v): compute expected values only for modes in the given range\n\nExamples\n\nN = 10\n\ns = sb_siteinds(\"Boson\", N)\nv = sb_outer(random_mps(s; linkdims=4))\nexpect(v, \"N\")  # compute for all sites\nexpect(v, \"N\"; sites=2:4)  # compute for sites 2, 3 and 4\nexpect(v, \"N\"; sites=3)  # compute for site 3 only (output will be a scalar)\nexpect(v, [\"A*Adag\", \"N\"])  # compute A*Adag and N for all sites\nexpect(v, [0 0; 0 1])  # same as expect(v, \"N\") if maxnumber == 1\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorMPS.correlation_matrix","page":"Reference","title":"ITensorMPS.correlation_matrix","text":"correlation_matrix(\n    v::SuperBosonMPS, A::AbstractString, B::AbstractString; kwargs...\n)\n\ncorrelation_matrix(\n    v::SuperBosonMPS, A::Matrix{<:Number}, B::Matrix{<:Number}; kwargs...\n)\n\nGiven a SuperBosonMPS v representing a state ρ and two strings or matrices A and B denoting operators (as recognized by the op function), computes the two-point correlation function matrix C_ij = textrmtr(A_i B_j ρ) using efficient MPS techniques. Returns the matrix C.\n\nOptional keyword arguments\n\nsites = 1:nmodes(v): compute correlations only for sites in the given range\nishermitian = false : if false, force independent calculations of the matrix elements above and below the diagonal, while if true assume they are complex conjugates.\n\nExamples\n\njulia> s = siteinds(\"Boson\", 3; dim=4);\n\njulia> vac = sb_outer(MPS(ComplexF64, s, \"0\"));\n\njulia> correlation_matrix(vac, \"x\", \"x\")\n3×3 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im  0.0+0.0im\n 0.0-0.0im  0.5+0.0im  0.0+0.0im\n 0.0-0.0im  0.0-0.0im  0.5+0.0im\n\njulia> correlation_matrix(vac, \"p\", \"x\")\n3×3 Matrix{ComplexF64}:\n 0.0-0.5im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0-0.5im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0-0.5im\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorMPS.sample","page":"Reference","title":"ITensorMPS.sample","text":"sample(m::SuperBosonMPS)\n\nGiven a \"superbosonic\" MPS m with unit trace, compute a Vector{Int} of nmodes(m) elements corresponding to one sample of the probability distribution defined by the components of the density matrix that the MPS represents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gaussian-states-and-operations","page":"Reference","title":"Gaussian states and operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"This package works in tandem with the GaussianStates package, extending some of its methods to define them on matrix-product states (both ordinary and superbosonic ones).","category":"page"},{"location":"reference/#First-and-second-moments","page":"Reference","title":"First and second moments","text":"","category":"section"},{"location":"reference/#GaussianBosonSamplingMPS.firstmoments","page":"Reference","title":"GaussianBosonSamplingMPS.firstmoments","text":"firstmoments(v; warn_atol=1e-14)\n\nCompute the first moments of the state v; return a vector in the xpxp order, i.e. the vector (x_1 p_1 x_2 p_2  x_N p_N).\n\nThe warn_atol keyword argument can be used to adjust the threshold used by the function to warn when the moments are not real.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.covariancematrix","page":"Reference","title":"GaussianBosonSamplingMPS.covariancematrix","text":"covariancematrix(v; warn_atol=1e-14)\n\nCompute the covariance matrix of the state v, in the xpxp order.\n\nThe warn_atol keyword argument can be used to adjust the threshold used by the function to warn when the moments are not real.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Gaussian-operations","page":"Reference","title":"Gaussian operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following methods can be applied to an MPS in order to simulate quantum optical operations.","category":"page"},{"location":"reference/#GaussianBosonSamplingMPS.attenuate","page":"Reference","title":"GaussianBosonSamplingMPS.attenuate","text":"attenuate(v::SuperBosonMPS, attenuation, n)\n\nApply on mode n the attenuator channel ρ  sum_k=0^+ B_k ρ adjB_k on the MPS v representing the state ρ in the superboson formalism, where\n\nB_k = sum_m=0^+ binomm+kk^frac12 (1-η^2)^frack2 η^m mm+k\n\nand η is the attenuation coefficient, such that sum_k=0^+infty B_k ρ adjB_k is equal to 00 when η = 0 and to ρ when η = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.displace","page":"Reference","title":"GaussianStates.displace","text":"displace(m::MPS, α; kwargs...)\n\nApply a product of single-mode displacement operators on the pure state represented by the MPS m, with parameter α[j] on mode j.\n\n\n\n\n\ndisplace(v::MPS, α; kwargs...)\n\nApply a product of single-mode displacement operators, with parameter α[j] on mode j, on the mixed state represented by the SuperBosonMPS v in the superboson formalism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.squeeze","page":"Reference","title":"GaussianStates.squeeze","text":"squeeze(v::SuperBosonMPS, n, z; kwargs...)\n\nApply the squeezing operator with parameter z on mode n to the state represented by v.\n\n\n\n\n\nsqueeze(v::SuperBosonMPS, z; kwargs...)\n\nApply the squeezing operator with parameter z_i on each mode i to the state represented by v.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianStates.beamsplitter","page":"Reference","title":"GaussianStates.beamsplitter","text":"beamsplitter(v::SuperBosonMPS, transmittivity, n1, n2; kwargs...)\n\nApply a beam-splitter operator on modes n1 and n2 with given transmittivity to the state represented by v.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Boson-sampling-output-simulation","page":"Reference","title":"Boson sampling output simulation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Here lies the heart of this package: the following methods implement the algorithms in [1] and [2] in order to be able to simulate a Gaussian boson sampling experiment with matrix-product states.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The main functions are the following.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"optimise uses semi-definite programming, through the JuMP and SCS libraries, to decompose the covariance matrix of a Gaussian state into a sum of\na pure covariance matrix which \"contains\" a smaller amount of photons,\na positive semi-definite matrix\nfollowing the procedure detailed in [1].\nMPS computes a matrix-product state that approximates a pure Gaussian state following the algorithm presented in [1], by using the Franck-Condon formula from [2].\nsample_displaced samples from a state after the application of a random displacement channel.","category":"page"},{"location":"reference/#GaussianBosonSamplingMPS.normal_mode_decomposition","page":"Reference","title":"GaussianBosonSamplingMPS.normal_mode_decomposition","text":"normal_mode_decomposition(g::GaussianState, N, maxnumber; kwargs...)\n\nCompute the normal-mode decomposition [5, Eq. (3.60) at page 47] of the Gaussian state g up to the N largest eigenvalues, calculated by considering only the k-particle sectors for k ≤ maxnumber on each mode. Return vals, nums, S where vals contains the eigenvalues in decreasing order, nums contains the occupation numbers of the Fock basis vector associated to the corresponding value in vals, and S is the symplectic matrix from the Williamson decomposition of g.\n\nThe output satisfies the following identities:\n\njulia> D, S = williamson(Symmetric(g.covariance_matrix));\n\njulia> d = diag(D)[1:2:end];\n\njulia> normalmode_evs, nums, S' = normal_mode_decomposition(g, N, maxnumber);\n\njulia> all(\n    val == prod(normal_mode_eigenvalue(d[j], m[j]) for j in eachindex(m)) for\n    (val, m) in zip(normalmode_evs, nums)\n)\ntrue\n\njulia> S == S'\ntrue\n\nReferences\n\n[5] Serafini, A. (2023)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.franckcondon","page":"Reference","title":"GaussianBosonSamplingMPS.franckcondon","text":"franckcondon(m, α, Wₗ, S, Wᵣ, n)\nfranckcondon(m, Wₗ, S, Wᵣ, n)\n\nCompute the matrix element m D(α) U(W_l) U(S) U(W_r) n according to the algorithm presented in Ref. [2]. Wₗ, S and Wᵣ are symplectic matrices, in particular Wₗ and Wᵣ are also orthogonal, and α is a complex vector (which defaults to the zero vector). If N is the number of modes of the system, then\n\nm and n are tuples of N natural numbers,\nα is a vector of N complex numbers,\nWₗ, S and Wᵣ are 2N  2N matrices.\n\nReferences\n\n[2] Quesada, N. J Chem Phys 150.16 (2019)\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorMPS.MPS","page":"Reference","title":"ITensorMPS.MPS","text":"MPS(g::GaussianState; maxdim, maxnumber, kwargs...)\n\nBuild an MPS representation of the Gaussian state g with bond dimension up to maxdim, truncating the Fock space of each mode at the maxnumber-particle sector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GaussianBosonSamplingMPS.optimise","page":"Reference","title":"GaussianBosonSamplingMPS.optimise","text":"optimise(g::GaussianState; verbose=false, scs_eps=nothing)\n\nReturn gₚ, W where gₚ is a new Gaussian state and W is a positive semi-definite matrix such that W + gₚ.covariance_matrix == g.covariance_matrix and gₚ contains a smaller number of photons.\n\nSet verbose = true to print the information provided by SCS about the optimisation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GaussianBosonSamplingMPS.sample_displaced","page":"Reference","title":"GaussianBosonSamplingMPS.sample_displaced","text":"sample_displaced(ψ::MPS, W; nsamples, nsamples_per_displacement, eval_atol=0, kwargs...)\n\nApply random displacements sampled from the positive semi-definite matrix W to the pure state ψ and sample nsamples elements from the resulting state.\n\nReturn s, αs such that:\n\ns is a matrix of UInt8 elements such that each column is a sample drawn from the final state, with a new displacement vector for each nsamples_per_displacement draws. (The matrix will actually have a number of columns equal to nsamples_per_displacement * floor(nsamples / nsamples_per_displacement).)\nαs is a matrix whose columns are the displacement vectors drawn from W, such that αs[:, k] is used for the samples from (k-1)N to kN, with N = floor(nsamples / nsamples_per_displacement).\n\nThe eval_atol keyword argument is used as threshold to decide whether an eigenvalue of W must be considered zero (usually it should be of the same order of the eps tolerances of the SCS optimiser).\n\n\n\n\n\n","category":"function"},{"location":"#GaussianBosonSamplingMPS.jl","page":"Home","title":"GaussianBosonSamplingMPS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for the GaussianBosonSamplingMPS.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements the tensor-network-based algorithm for simulating Gaussian boson sampling experiments proposed in [1], and of the algorithm in [2] for computing elements of Gaussian operations in the Fock number basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions for computing hafnians and loop hafnians of square matrices are ported from The Walrus [3].","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulate a linear optical quantum computer with matrix-product states (MPS) through the application of common operations such as one- and two-mode squeezing, beam splitters, etc. and also simulate losses through an attenuator channel.\nManipulate MPS (and sample from them) representing mixed states in the superboson formalism [4].\nFind an approximate MPS representation of a Gaussian state in the Fock basis\nSample from the outcome of a lossy Gaussian boson sampling experiment with the classical MPS-based algorithm described in [1].","category":"page"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"C. Oh, M. Liu, Y. Alexeev, B. Fefferman and L. Jiang. Classical algorithm for simulating experimental Gaussian boson sampling. Nature Physics 20, 1461–1468 (2024).\n\n\n\nN. Quesada. Franck-Condon factors by counting perfect matchings of graphs with loops. The Journal of Chemical Physics 150, 164113–164113 (2019).\n\n\n\nB. Gupt, J. Izaac and N. Quesada. The Walrus: a library for the calculation of hafnians, Hermite polynomials and Gaussian boson sampling. Journal of Open Source Software 4, 1705 (2019).\n\n\n\nM. Schmutz. Real-time Green's functions in many body problems. Zeitschrift für Physik B Condensed Matter 30, 97–106 (1978).\n\n\n\nA. Serafini. Quantum Continuous Variables (CRC Press, 2023).\n\n\n\n","category":"page"}]
}
